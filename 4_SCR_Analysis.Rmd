---
title: "SCR Analysis"
output: 
  html_document

---

<!-- Set general settings -->

```{r setup, include = FALSE}

# Set general settings for markdown file
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  comment = "",
  results = "hold"
)


# Clear environment
rm(list = ls())


# Enable/disable caching of time-consuming code chunks
knitr_cache_enabled = TRUE


# Load packages
library(dplyr)      # for data manipulation
library(knitr)      # for integrating computing and reporting in markdown
library(kableExtra) # for customizing appearance of tables
library(ggplot2)    # for plotting
library(cowplot)    # for arranging plots
library(e1071)      # for functions skewness and kurtosis
library(MASS)       # for boxcox function and contrast definition
library(lme4)       # for (G)LMMs
library(lmerTest)   # for LMM p values (Satterthwaite's method for approximating dfs for the t and F tests)
library(sjPlot)     # for tab_model function to display (G)LMM results
library(performance)# for check of model various assumptions


# Load functions
source("./functions/summarySEwithinO.R")  # Function provided by R-cookbook: http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/
source("./functions/my_table_template.R") # Function to create table template
source("./functions/R_rainclouds.R")      # Function to create raincloud plots


# Turn off scientific notation
options(scipen = 999)


# Set figure theme and colors
my_figure_theme <- theme_classic(base_size = 11) +
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill="grey95", linetype = "blank"),
        axis.ticks.x = element_blank(), 
        plot.title = element_text(hjust = 0.5)) 
# instad of theme_classic: + theme_apa(base_size = 11)

my_figure_colors <- c("#8ea6b4", "#465369")
```
<br><br> 

## Data Cleaning
***

```{r load-and-clean-data}

# Load data
load(file = "./data/Single_Trial_Data.rda")


# Exclude P_02 (due to retainer) and C_02 (as preregistered: patients are excluded with their match)
single_trial_data <- single_trial_data[single_trial_data$participant_id != "P_02" & single_trial_data$participant_id != "C_02",]


# Determine trials preceding or following an error (to minimize effects of overlapping events)
single_trial_data <- single_trial_data %>%
  dplyr::mutate(
    followed_or_preceded_by_error = ifelse(lag(response_type == "incorrect", default = FALSE) == TRUE, TRUE,
                                           ifelse(lead(response_type == "incorrect", default = FALSE) == TRUE, TRUE, FALSE))
    ) 


# For each first or last trial in a block, followed_or_preceded_by_error is FALSE
single_trial_data[single_trial_data$trial == 1   |
                  single_trial_data$trial == 80  | single_trial_data$trial == 81 |
                  single_trial_data$trial == 160 | single_trial_data$trial == 161| 
                  single_trial_data$trial == 240 | single_trial_data$trial == 241|
                  single_trial_data$trial == 320 | single_trial_data$trial == 321|
                  single_trial_data$trial == 400 | single_trial_data$trial == 401| 
                  single_trial_data$trial == 480, "followed_or_preceded_by_error"] <- FALSE


# Exclude missing responses, RT outliers and trials with ERP artifacts, trials with NA for SCR (= no additional trials), trials preceding or following an error
single_trial_data_clean <- single_trial_data %>%
  dplyr::filter(
      response_type != "miss" &
      rt_invalid  == FALSE &
      !is.na(MFN_0_100_FCz) &
      !is.na(ISCR) &
      followed_or_preceded_by_error == FALSE  
  ) # (46973 of 53760 trials left)


# Add column for (grand mean standardized) number of errors (needed as covariate later) - this variable contains total number of errors, not only those entering analysis (preferred according to JK)
single_trial_data_clean <- single_trial_data %>% 
  dplyr::group_by(participant_id, session) %>% 
  dplyr::summarize(number_errors = sum(response_type == "incorrect")) %>%
  dplyr::ungroup(.) %>%
  dplyr::mutate(number_errors_standardized = scale(number_errors, center = TRUE, scale = TRUE)) %>%
  dplyr::left_join(single_trial_data_clean, ., by = c("participant_id", "session"))



# Add column for medication (needed as covariate later) 
single_trial_data_clean <- single_trial_data_clean %>% 
  dplyr::mutate(medication = as.factor(ifelse(participant_id == "P_02" | participant_id == "P_04" | participant_id == "P_05" |
                                              participant_id == "P_06" | participant_id == "P_08" | participant_id == "P_10" |
                                              participant_id == "P_15" | participant_id == "P_16" | participant_id == "P_18" |
                                              participant_id == "P_22" | participant_id == "P_25" | participant_id == "P_26" |
                                              participant_id == "P_28" | participant_id == "P_30", "yes", "no")))


# Calculate sqrt transformed SCR (closer to normality than log transformed), standardized SCR, and standardized MFN
single_trial_data_clean <- single_trial_data_clean %>%
  dplyr::group_by(participant_id, session) %>%
  dplyr::mutate(
      ISCR_sqrt        = sqrt(ISCR),
      ISCR_z           = scale(ISCR, center = TRUE, scale = TRUE),
      MFN_0_100_FCz_z  = scale(MFN_0_100_FCz, center = TRUE, scale = TRUE)
    ) %>%
  dplyr::ungroup()


# Calculate aggregated data per participant for boxplots
df_aggregated_per_subject_SCR <- single_trial_data_clean %>%
  dplyr::group_by(participant_id, group, response_type, stimulation, session) %>%
  dplyr::summarize(
    ISCR_z = mean(ISCR_z, na.rm = TRUE)
   )  %>%
  dplyr::ungroup()


# Make categorical variables factors
single_trial_data_clean$participant_id      <- as.factor(single_trial_data_clean$participant_id) 
single_trial_data_clean$group               <- as.factor(single_trial_data_clean$group)
single_trial_data_clean$session             <- as.factor(single_trial_data_clean$session)
single_trial_data_clean$stimulation         <- as.factor(single_trial_data_clean$stimulation)
single_trial_data_clean$response_type       <- as.factor(single_trial_data_clean$response_type)
```

Trials were excluded from all analyses if RT was shorter than 100 ms or longer than 800 ms or if the response in a trial was missing. We further discarded trials containing artifacts in the EEG, i.e., a voltage difference exceeding 50 μV between two consecutive sampling points or 200 μV within an epoch.
In addition, we here excluded trials preceding or following an error (so that SCR was not confounded by previous or following events within the response window that may elicit
pronounced changes of skin conductance).
<br><br>
In this analysis, ISCR values for the time window 1-5 s after the response were extracted for each trial. Common recommendations for response windows typically range from from 1 to 3 s up to 1 to 5 s after the stimulus (Dawson et al., 2007; Benedek & Kaernbach, 2010). I chose 1 to 5 s after the response because this is also compatible with the observed response window in the data (based on visual inspection in BVA of correct vs. error condition). Note however, that 1 to 4 s was stated in the preregistration.
<br><br>

## Data Inspection {.tabset}
***

### Distribution

```{r inspect-distribution, cache = knitr_cache_enabled}

# Plot distribution ISCR
hist_ISCR <- ggplot(single_trial_data_clean, aes(x = ISCR)) +
  geom_histogram(aes(y = ..density..), color="gray33", fill = "#8ea6b4", size = 1) +
  stat_function(fun = dnorm, args=list(mean = mean(single_trial_data_clean$ISCR, na.rm = TRUE), 
                                     sd = sd(single_trial_data_clean$ISCR, na.rm = TRUE)), color = "black", size = 0.5) +
  geom_vline(aes(xintercept = mean(ISCR, na.rm = TRUE)), color = "black", linetype = "dashed", size = 1) +
  labs (title = "Histogram ISCR", x = "ISCR", y = "Density") + 
  my_figure_theme 

qqplot_ISCR <- ggplot(single_trial_data_clean, aes(sample = ISCR)) +
  stat_qq(color = "#8ea6b4") +
  stat_qq_line() +
  labs (title = "Q-Q-Plot ISCR", x = "Theoretical Quantiles", y = "Sample Quantiles") + 
  my_figure_theme


# Plot distribution ISCR sqrt
hist_ISCR_sqrt <- ggplot(single_trial_data_clean, aes(x = ISCR_sqrt)) +
  geom_histogram(aes(y = ..density..), color="gray33", fill = "#8ea6b4", size = 1) +
  stat_function(fun = dnorm, args=list(mean = mean(single_trial_data_clean$ISCR_sqrt, na.rm = TRUE), 
                                     sd = sd(single_trial_data_clean$ISCR_sqrt, na.rm = TRUE)), color = "black", size = 0.5) +
  geom_vline(aes(xintercept = mean(ISCR_sqrt, na.rm = TRUE)), color = "black", linetype = "dashed", size = 1) +
  labs (title = "Histogram ISCR_sqrt", x = "ISCR_sqrt", y = "Density") + 
  my_figure_theme

qqplot_ISCR_sqrt <- ggplot(single_trial_data_clean, aes(sample = ISCR_sqrt)) +
  stat_qq(color = "#8ea6b4") +
  stat_qq_line() +
  labs (title = "Q-Q-Plot ISCR_sqrt", x = "Theoretical Quantiles", y = "Sample Quantiles") + 
  my_figure_theme


ggdraw() +
  draw_plot(hist_ISCR,       x =  0,   y = .5,   width = .5, height = .5) +
  draw_plot(qqplot_ISCR,     x =  .5,  y = .5,   width = .5, height = .5) +
  draw_plot(hist_ISCR_sqrt,  x =  0,   y = .0,   width = .5, height = .5) +
  draw_plot(qqplot_ISCR_sqrt,x =  .5,  y = .0,   width = .5, height = .5) 
```
<br><br>

### SCR per participant 

```{r plot-SCR-per-participant-and-response-type, fig.width = 12, fig.height = 20, cache = knitr_cache_enabled}

SCR_per_participant <- ggplot(single_trial_data_clean, aes(x = response_type, y = ISCR_sqrt, group = response_type)) + 
  geom_point(aes(fill = response_type), color = "black", shape = 21, position = "jitter") + 
  ggtitle("SCR (sqrt transformed) per participant") + 
  my_figure_theme + 
  facet_wrap(~ participant_id + stimulation, ncol = 10) +
  scale_fill_manual(values = my_figure_colors) 
SCR_per_participant
```
<br><br>

### Check Normality 

For the single-trial data, Shapiro-Wilk is not suitable, as it always returns a significant result for such large samples (additionally, it can handle only samples up to 5000). Hence, we have to rely on visual inspection (see tab "Distribution") and values of skewness and kurtosis (see below). Values for skewness and kurtosis between -2 and +2 are considered acceptable in order to prove normal univariate distribution (George & Mallery, 2010).

```{r normality-single-trial-SCR}

normality_SCR <- round(data.frame(matrix(c(skewness(single_trial_data_clean$ISCR),
                                           kurtosis(single_trial_data_clean$ISCR),
                                           skewness(single_trial_data_clean$ISCR_sqrt),
                                           kurtosis(single_trial_data_clean$ISCR_sqrt)),
                                        nrow=2, ncol = 2)),digits = 1)
rownames(normality_SCR) <- c("Skewness","Kurtosis")
colnames(normality_SCR) <- c("ISCR", "ISCR sqrt")

my_table_template(normality_SCR, row_names = TRUE)
```
<br><br>

## Descriptive Statistics {.tabset}
***

### Means and CIs

```{r descriptive-statistics-table}

# Calculate descriptive statistics for SCR per condition
descriptive_statistics_SCR <- summarySEwithinO(
  data          = single_trial_data_clean,
  measurevar    = "ISCR_z",
  withinvars    = c("response_type", "stimulation", "session"),
  betweenvars   = "group",
  idvar         = "participant_id", 
  conf.interval = .95) %>%
  # Format confidence interval column
  dplyr::mutate(
    ci_SCR = paste0("[", round(ISCR_z - ci, digits = 2), 
                   ", ", round(ISCR_z + ci, digits = 2), "]")) %>%
  # Round SCR means to two decimals
  dplyr::mutate_at("ISCR_z", round, digits = 2) %>%    
  # Select columns to be displayed
  dplyr::select(c("group", "response_type", "stimulation", "session", "ISCR_z", "ci_SCR", "ci"))


# Split and re-merge SCR table to display both groups next to each other
descriptive_statistics_SCR_display <-  split(descriptive_statistics_SCR, descriptive_statistics_SCR$group)
descriptive_statistics_SCR_display <-  left_join(descriptive_statistics_SCR_display$HC, descriptive_statistics_SCR_display$OCD, 
                                                 by = c("response_type", "stimulation", "session"))


# Display descriptive statistics for SCR (and select columns)
my_table_template(descriptive_statistics_SCR_display[,c(2:6,9:10)],
  caption = "Standardized SCR (in μS)",
  col_names = c("Response type", "Stimulation", "Session", "M", "95% CI", "M", "95% CI"),
  header_above_config = c(" " = 3, "HC" = 2, "OCD" = 2),
  footnote_config = c(general = "Confidence intervals are adjusted for within-participant designs as described by Morey (2008).")
)



# Calcuate means and CIs adjusted for within-participant factors (without session) - for plots
descriptive_statistics_SCR_no_session <- summarySEwithinO(
  data          = single_trial_data_clean,
  measurevar    = "ISCR_z",
  withinvars    = c("response_type", "stimulation"),
  betweenvars   = "group",
  idvar         = "participant_id", 
  conf.interval = .95
)
```
<br><br>

### Plot without session

```{r descriptive-statistics-plot-SCR, fig.width = 8, fig.height = 7, fig.cap = "Note. Response-locked SCR in the flanker task is shown as a function of response type, stimulation condition, and group. Means and 95% confidence intervals (shown in orange/red) were calculated based on single-trial data. Boxplots are based on data aggregated by participant. CIs are adjusted for within-participant designs as described by Morey (2008)."}

# Create plot SCR 
plot_SCR <- ggplot() +
  geom_boxplot(data = df_aggregated_per_subject_SCR, aes(x = stimulation, y = ISCR_z, fill = group), outlier.size =0.3)+
  geom_point(data = descriptive_statistics_SCR_no_session, aes(x = stimulation, y = ISCR_z, colour = group), 
             position = position_dodge(width = 0.7), shape = 15, size = 1) +
  geom_errorbar(data = descriptive_statistics_SCR_no_session, aes(x = stimulation, ymax = ISCR_z + ci, ymin = ISCR_z - ci, colour = group),
                position = position_dodge(width = 0.7), width = 0, size = 0.5) +
  geom_line(data = descriptive_statistics_SCR_no_session, aes(x = stimulation, y = ISCR_z, group = group, color = group), 
            position = position_dodge(width = 0.7), linetype = 3, size = 0.5) +
  scale_colour_manual(values = c("#b23f00", "#ff9b64"), name = "Group:") +
  scale_fill_manual(values = my_figure_colors, name = "Group:") +
  facet_wrap(~response_type, nrow = 1) +
  my_figure_theme + 
  labs(x = "\nStimulation condition", y = "Standardized SCR (μS)")


# Save plot
ggsave("./figures/figure_SCR.tiff", width = 12, height = 12, units = "cm", dpi=600, compression = "lzw")


# Display plot
plot_SCR
``` 
<br><br>

### Plot with session

```{r descriptive-statistics-plot-including-session, fig.width = 10, fig.height = 7, fig.cap = "Note. Response-locked SCR in the flanker task is shown as a function of response type, stimulation condition, group, and session. Means and 95% confidence intervals (shown in orange/red) were calculated based on single-trial data. Boxplots are based on data aggregated by participant. CIs are adjusted for within-participant designs as described by Morey (2008)."}

# Create plot SCR 
plot_SCR_session <- ggplot() +
  geom_boxplot(data = df_aggregated_per_subject_SCR, aes(x = stimulation, y = ISCR_z, fill = group), outlier.size =0.3)+
  geom_point(data = descriptive_statistics_SCR, aes(x = stimulation, y = ISCR_z, colour = group), 
             position = position_dodge(width = 0.7), shape = 15, size = 1) +
  geom_errorbar(data = descriptive_statistics_SCR, aes(x = stimulation, ymax = ISCR_z + ci, ymin = ISCR_z - ci, colour = group),
                position = position_dodge(width = 0.7), width = 0, size = 0.5) +
  geom_line(data = descriptive_statistics_SCR, aes(x = stimulation, y = ISCR_z, group = group, color = group), 
            position = position_dodge(width = 0.7), linetype = 3, size = 0.5) +
  scale_colour_manual(values = c("#b23f00", "#ff9b64"), name = "Group:") +
  scale_fill_manual(values = my_figure_colors, name = "Group:") +
  facet_wrap(~response_type + session, nrow = 1) +
  my_figure_theme + 
  labs(x = "\nStimulation condition", y = "Standardized SCR (μS)") 


# Save plot
ggsave("./figures/figure_SCR_session.tiff", width = 20, height = 25, units = "cm", dpi=600, compression = "lzw")


# Display plot
plot_SCR_session
```  
<br><br>

### Physiological nonresponders

Participants exhibiting no measurable SCR (i.e., ISCR scores of zero) in more than 75% of all trials were classified as physiological nonresponders. All participants were below this threshold, so no participants were excluded from SCR analyses.

```{r nonresponders}

# Calculate percentage of zero responses (based on all trials)
zero_responses <- single_trial_data[!is.na(single_trial_data$ISCR), ] %>%
  dplyr::group_by(participant_id, session) %>%
  dplyr::summarize(
    percentage_zero_responses = length(participant_id[ISCR == 0]) / length(participant_id) * 100
  ) %>%
  dplyr::ungroup()
```

Percentage of zero responses: *M* = `r round(mean(zero_responses$percentage_zero_responses), digits = 2)`%, *SD* = `r round(sd(zero_responses$percentage_zero_responses), digits = 2)`%, range = `r round(min(zero_responses$percentage_zero_responses), digits = 2)`–`r round(max(zero_responses$percentage_zero_responses), digits = 2)`%
<br><br><br>

## LMM Analyses
***

SCR was modeled using a linear mixed-effects model (LMM). <br><br>

**Fixed effects**

*Group (HC, OCD), stimulation (verum, sham), response type (correct, incorrect), and MFN (within-participant standardized)* were specified as fixed factors. Categorical fixed effects were coded using effect coding (this equals sliding difference contrasts for two levels for factors with two levels or sum coding/2), such that the intercept reflects the grand mean across all conditions and differences in means between factor levels are tested. Fixed effects were not eliminated using model comparison techniques because they correspond to the original experimental design and a priori hypotheses. <br><br>


**Random effects**

Participants were specified as random factors. The random-effects structure for each model was determined based on the procedure proposed by Bates, Kliegl, et al. (2015). We started with the maximal random-effects structure  that was justified by the design, including random intercepts for participants, as well as random slopes for all main effects and interactions specified as fixed effects. If the model with the maximal random-effects structure would not converge, correlations of the random terms were set to zero. We performed a principal components analysis on the random-effects variance–covariance estimates to determine the number of components supported by the data and removed random effects explaining zero variance to prevent overparametrization (Matuschek et al., 2017).

```{r SCR-LMM-contrast-coding}

# Define contrasts (sliding difference contrasts)
contrasts(single_trial_data_clean$stimulation)   <- contr.sdif(2)
contrasts(single_trial_data_clean$group)         <- contr.sdif(2)
contrasts(single_trial_data_clean$response_type) <- contr.sdif(2)
contrasts(single_trial_data_clean$session)       <- contr.sdif(2)
contrasts(single_trial_data_clean$medication)    <- contr.sdif(2)


# Add contrasts as numerical covariates via model matrix* (specify all possible contasts for now)
model_matrix <- model.matrix(~ stimulation * group * response_type, single_trial_data_clean)


# Attach the model matrix (16 columns) to the dataframe
single_trial_data_clean[, (ncol(single_trial_data_clean) + 1):(ncol(single_trial_data_clean) + 8)] <- model_matrix


# Assign descriptive names to the contrasts
names(single_trial_data_clean)[(ncol(single_trial_data_clean) - 7):ncol(single_trial_data_clean)] <- c("Grand Mean", "verum_sham", "OCD_HC", "incorrect_correct", "verum_sham:OCD_HC", "verum_sham:incorrect_correct", "OCD_HC:incorrect_correct", "verum_sham:OCD_HC:incorrect_correct")


# *Note: For the random effects, we needed to enter the separate random effect terms in the models to enable
# double-bar notation (||). This allows fitting a model that sets correlations of the random terms to zero.
```
<br><br>

### LMM for SCR {.tabset}

#### Model

This is the overall model, including error and correct trials. This model would be reported before reporting the model only on error-trials, because it also shows that SCR is increased after errors compared to correct responses. 

```{r LMM-SCR, cache = knitr_cache_enabled}

# Run final model (removed correlations between random terms to achieve convergence; removed random terms that explain < 0.5% of variance (MFN, MFN:response_type, MFN:stimulation))
LMM_SCR <- lmer(ISCR_sqrt ~ verum_sham * OCD_HC * incorrect_correct * MFN_0_100_FCz_z +
  (1 + verum_sham + incorrect_correct + verum_sham:incorrect_correct + MFN_0_100_FCz_z:verum_sham:incorrect_correct || participant_id),
data = single_trial_data_clean,
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)


# Check model output
# summary(LMM_SCR) # Model does converge
# isSingular(LMM_SCR) # Check for singular model fit (i.e., dimensions of the variance-covariance matrix have been estimated as exactly zero): FALSE


# Check PCA of random-effects variance-covariance estimates
# summary(rePCA(LMM_SCR)) # All terms explain variance (> 0.5%)


# Display results (fixed effects)
tab_model(LMM_SCR,
  dv.labels = "SCR [μS]", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = TRUE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)
```
<br><br>
There is a main effect of response type (i.e., higher SCR following errors than following correct responses). There is also a trend/significant result for quite complex and difficult to interpret interactions (significant:stimulation:group:MFN and stimulation:MFN; Trend: stimulation:group:response_type and response_type:MFN). 
<br><br>

#### Assumption checks 

```{r LMM-SCR-assumptions, fig.width = 20, fig.height = 15, cache = knitr_cache_enabled}

# Check model assumptions
performance::check_model(LMM_SCR, panel = TRUE)

# In addition to plots, print verbal output for some assumption tests to facilitate conclusion
print("# Check for heteroscedasticity")
performance::check_heteroscedasticity(LMM_SCR)

print("# Check for influential observations (Cook's distance)")
performance::check_outliers(LMM_SCR, effects = "random")

print("# Check for normal distributed random effects")
performance::check_normality(LMM_SCR, effects = "random")
```

* **Assumption 1: Independence of Data Points / Absence of collinearity -> Is OK**
    + Are predictors not highly correlated?
    + Multicollinearity plot shows only low correlations 

* **Assumption 2: Normality of Residuals -> Not OK!** 
    + Are residuals approximately normally distributed?
    + Q-Q plot and density plot look not so great; Q-Q plot really off at the extremes 
    + It is debated whether this is problematic at all, so maybe not worry about it? 

* **Assumption 3: Linearity -> Not OK!** 
    + Is the dependent variable linearly related to the fixed factors, random factors, and covariates?
    + Plot of the residuals against the fitted values shows not a random scatter pattern, rather a nonlinear or curvy pattern 

* **Assumption 4: Homogeneity of Residual Variance (Heteroscedasticity) -> Not OK!**
    + Have residuals constant variance across the range of the predicted values?
    + Plot of the residuals against the fitted values shows not an even spread around the centered line; also written output says this is not ok

* **Assumption 5: Absence of Influential Data Points -> Is OK** 
    + Are there are no influential values? 
    + Cook's distance plot looks fine (for large N, Cook's distances should be below 1) and written output says there are no outliers 

* **Assumption 6: Normality of Random Effects -> Not OK!**
    + Are random effects approximately normally distributed?
    + Written output says this is only partly ok 
<br><br>

### LMM for error-related SCR {.tabset}

#### Model

```{r LMM-SCR-errors, cache = knitr_cache_enabled}

# Run final model (removed correlations between random terms to achieve convergence; removed random term (MFN:stimulation) that explains < 0.5% of variance)
LMM_SCR_errors <- lmer(ISCR_sqrt ~ verum_sham * OCD_HC * MFN_0_100_FCz_z +
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)


# Check model output
# summary(LMM_SCR_errors) # Model does converge
# isSingular(LMM_SCR_errors) # Check for singular model fit (i.e., dimensions of the variance-covariance matrix have been estimated as exactly zero): FALSE


# Check PCA of random-effects variance-covariance estimates
# summary(rePCA(LMM_SCR_errors)) # All terms explain variance (> 0.5%)


tab_model(LMM_SCR_errors,
  dv.labels = "Error-related SCR [μS]", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = TRUE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)
```
<br><br>
There is no simple group or stimulation effect on error-related SCR. Also, ERN amplitude does not predict error-related SCR. (All this also holds true when only running model with stimulation + group + group:stimulation + MFN as perdictors.) There is a complex interaction group:stimulation:ERN that I find difficult to interpret. 
<br><br>

#### Assumption checks

```{r LMM-SCR-errors-assumptions, fig.width = 20, fig.height = 15, cache = knitr_cache_enabled}

# ERN check model assumptions
performance::check_model(LMM_SCR_errors, panel = TRUE)

# In addition to plots, print verbal output for some assumption tests to facilitate conclusion
print("# Check for heteroscedasticity")
performance::check_heteroscedasticity(LMM_SCR_errors)

print("# Check for influential observations (Cook's distance)")
performance::check_outliers(LMM_SCR_errors, effects = "random")

print("# Check for normal distributed random effects")
performance::check_normality(LMM_SCR_errors, effects = "random")
```

Notes for assumption check would be the same as written for the model on all trials.
<br><br>

#### Plot interaction group x stimulation x ERN

The plot shows the predicted values (marginal effects) for the interaction group:stimulation:ERN. 

```{r plot-interaction-group-stimulation-ERN, cache = knitr_cache_enabled, fig.width = 8, fig.cap = "Note. Estimated interaction effect of group x stimulation x ERN in the flanker task  on skin conductance response (SCR). Shaded areas represent 95% confidence intervals. HC = healthy control participants, OCD = patients with OCD, SQRT = square root."}

# Respecify LMM: Enter fixed effects as factors, not contrasts (to have all factor levels in the plot)
# Double bar syntax for zero-correlation parameter model won't work anymore (full model still converges, no singular fit, results are pretty much the same)
LMM_scr_errors_plot <- lmer(ISCR_sqrt ~ stimulation * group * MFN_0_100_FCz_z +
  (1 + verum_sham + MFN_0_100_FCz_z | participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)

# Create plot marginal effects 
plot_scr_interaction_group_stimulation_ERN <- plot_model(LMM_scr_errors_plot,
                                type   = "pred",
                                terms  = c("MFN_0_100_FCz_z", "stimulation", "group"),
                                ci.lvl = .95) +
  labs(title = NULL, 
       x     = "ERN (Standardized [µV])", 
       y     = "SCR (SQRT-Transformed [µS]") +
  my_figure_theme +
  aes(linetype = group, color = group) + 
  scale_linetype_manual(name = "Stimulation", values = c("solid",   "dashed")) +
  scale_color_manual(name =    "Stimulation", values = c("#ffad48", "#43b7c2")) +
  coord_cartesian(ylim = c(0, 1), xlim = c(-6, 4)) +
  scale_y_continuous(breaks=seq(0, 1, 0.2), expand = c(0,0)) +
  scale_x_continuous(breaks=seq(-6, 4, 2),  expand = c(0,0)) + 
  theme(axis.ticks.x = NULL)  


# Save plot
# ggsave("figure_scr_interaction_group_stimulation_ERN.tiff", width = 20, height = 12 , units = "cm", dpi=600, compression = "lzw")


# Display plot
plot_scr_interaction_group_stimulation_ERN
```
<br><br>

#### Check covariates

The purpose of including the covariates was to see how the effects change when controlling for the overall effect of the covariate. Thus, covariates were included only as fixed factor, not as random term. I first included the covariates as main effect only, not allowing any interactions with stimulation or group. However, inspecting the interactions as well might lead to new, important insights. These models including the interactions are presented below.
Note: The covariate number of errors refers to the actual number of errors committed by each participant, not the number included in the analyses. Continuous predictors were grand mean standardized (number of errors). <br><br>
When including the covariates session, error number, medication, there is still no main effect of group, stimulation, or MFN. The strange interaction group:stimulation:MFN remains significant in all models. 

```{r LMM-SCR-errors-covariates, cache = knitr_cache_enabled}

# SCR check covariate session
LMM_SCR_errors_session <- lmer(ISCR_sqrt ~ verum_sham * OCD_HC * (MFN_0_100_FCz_z + session) +
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_session,
  dv.labels = "Error-related SCR [μS], covariate session", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)


# SCR check covariate number of errors (predictor was z standardized)
LMM_SCR_errors_number_errors <- lmer(ISCR_sqrt ~ verum_sham * OCD_HC * (MFN_0_100_FCz_z + number_errors_standardized)  + 
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_number_errors,
  dv.labels = "Error-related SCR [μS], covariate number of errors", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)


# SCR check covariate medication
LMM_SCR_errors_medication <- lmer(ISCR_sqrt ~ verum_sham * OCD_HC * (MFN_0_100_FCz_z + medication)  + 
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_medication,
  dv.labels = "Error-related SCR [μS], covariate medication", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)


# SCR include only unmedicated participants
LMM_SCR_errors_unmedicated <- lmer(ISCR_sqrt ~ verum_sham * OCD_HC * MFN_0_100_FCz_z  + 
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect" & single_trial_data_clean$medication == "no",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_unmedicated,
  dv.labels = "Error-related SCR [μS], only unmedicated participants", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)


# SCR include only unmedicated patients
LMM_SCR_errors_unmedicated_OCD <- lmer(ISCR_sqrt ~ verum_sham * MFN_0_100_FCz_z +  
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect" & single_trial_data_clean$medication == "no" & single_trial_data_clean$group == "OCD",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_unmedicated_OCD,
  dv.labels = "Error-related SCR [μS], only unmedicated patients", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)
```
<br><br>

### LMM for error-related SCR (nested) {.tabset}

#### Model

```{r LMM-SCR-errors-per-group, cache = knitr_cache_enabled}

# Run final model (use model specification as in unnested model)
LMM_SCR_errors_group <- lmer(ISCR_sqrt ~ group/stimulation * MFN_0_100_FCz_z +
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)


tab_model(LMM_SCR_errors_group,
  dv.labels = "Error-related SCR [μS]", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = TRUE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)
```
<br><br>
For the separate groups, there is no significant effect of stimulation or ERN. The strange interaction stimulation:ERN is significant only for the OCD group.
<br><br>

#### Assumption checks 

Is same as in non-nested model.
<br><br>

#### Check covariates

When including the covariates session, error number, medication, there is still no main effect of stimulation or MFN in the separate groups. The strange interaction stimulation:MFN in the OCD group remains significant in all models. 

```{r LMM-SCR-errors-per-group-covariates, cache = knitr_cache_enabled}

# SCR check covariate session
LMM_SCR_errors_group_session <- lmer(ISCR_sqrt ~ group/stimulation * (MFN_0_100_FCz_z + session) +
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_group_session,
  dv.labels = "Error-related SCR [μS], covariate session", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)


# SCR check covariate number of errors (predictor was z standardized)
LMM_SCR_errors_group_number_errors <- lmer(ISCR_sqrt ~ group/stimulation * (MFN_0_100_FCz_z + number_errors_standardized)  + 
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_group_number_errors,
  dv.labels = "Error-related SCR [μS], covariate number of errors", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)


# SCR check covariate medication
LMM_SCR_errors_group_medication <- lmer(ISCR_sqrt ~ group/stimulation * (MFN_0_100_FCz_z + medication)  + 
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_group_medication,
  dv.labels = "Error-related SCR [μS], covariate medication", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)


# SCR include only unmedicated participants
LMM_SCR_errors_group_unmedicated <- lmer(ISCR_sqrt ~ group/stimulation * MFN_0_100_FCz_z  + 
  (1 + verum_sham + MFN_0_100_FCz_z || participant_id),
data = single_trial_data_clean[single_trial_data_clean$response_type == "incorrect" & single_trial_data_clean$medication == "no",],
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)
# Convergence, singulatrity, PCA checked, all ok
tab_model(LMM_SCR_errors_group_unmedicated,
  dv.labels = "Error-related SCR [μS], only unmedicated participants", show.stat = TRUE, show.icc = TRUE, show.r2 = TRUE, 
  show.re.var = FALSE, show.ngroups = TRUE, string.est = "b", string.stat = "t value", 
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite", wrap.labels = 80, digits.re = 3
)
```
<br><br>

### LMM for relation SCR -PES

To test whether SCR predicts PES magnitude, we fitted a LMM on PES with the z-standardized SCR as predictor and by-participant random effects. We calculated single-trial values of PES by quantifying the RT difference between correct trials preceding and following an error (Dutilh et al., 2012). Errors were included in this analysis only if they were preceded by at least two correct responses and followed by at least one correct response. <br><br>
This analysis was performed to check whether we can replicate our earlier finding of a relation between SCR and PES. This analysis shall not be included in the manuscript.

```{r LMM-SCR-PES, cache = knitr_cache_enabled}

# Create column with single-trial PES (RTpost-error − RTpre-error for all CCEC sequences)
single_trial_data$pes <- NA
for (i in 3:(nrow(single_trial_data)-1)) {
  if (
      # Trial N must be error
      single_trial_data[i,]$response_type == "incorrect" &
      # Trial N-2, N-1 and N+1 must be correct
      single_trial_data[(i+1),]$response_type == "correct" &
      single_trial_data[(i-1),]$response_type == "correct" &
      single_trial_data[(i-2),]$response_type == "correct" &
      # Trial N, N+1, and N-1 must have valid rt (to have valid error and valid RTs for PES calculation)
      single_trial_data[(i + 1), ]$rt_invalid  == FALSE &
      single_trial_data[(i - 1), ]$rt_invalid  == FALSE &
      single_trial_data[(i    ), ]$rt_invalid  == FALSE &
      # Trial N-1 and N+1 must be directly preceding / following the error (just to make sure; should be the case,
      # as full/unfiltered data set is used here and errors in first/last trial of each participant are excluded below)
      single_trial_data[(i+1),]$trial - single_trial_data[(i-1),]$trial == 2) {
    single_trial_data[i,]$pes <- (single_trial_data[(i+1),]$rt) - (single_trial_data[(i-1),]$rt)
  }
}


# For each last first and trial in a block, PES cannot be determined; set these values to NA
single_trial_data[single_trial_data$trial == 1   |
                  single_trial_data$trial == 80  | single_trial_data$trial == 81 |
                  single_trial_data$trial == 160 | single_trial_data$trial == 161| 
                  single_trial_data$trial == 240 | single_trial_data$trial == 241|
                  single_trial_data$trial == 320 | single_trial_data$trial == 321|
                  single_trial_data$trial == 400 | single_trial_data$trial == 401| 
                  single_trial_data$trial == 480, "pes"] <- NA


# Density plot and q-q plot for PES values -> PES normally distributed, no transformation necessary
# par(mfrow = c(2, 2)) # arrange plots
# plot(density(single_trial_data[!is.na(single_trial_data$pes), ]$pes), main = "PES: Density  Plot")
# qqnorm(single_trial_data[!is.na(single_trial_data$pes), ]$pes, main = "PES: Q-Q Plot", pch = 1, frame = FALSE)
# par(mfrow = c(1, 1)) # reset layout


# Box–Cox procedure: lambda = 0.95, suggesting that no transformation is necessary (for lambda around 1)
# bc_pes <- boxcox(pes + 400 ~ 1, data = single_trial_data[!is.na(single_trial_data$pes), ])
# optlambda_pes <- bc_pes$x[which.max(bc_pes$y)]


# Calculate standardized SCR for trials entering PES LMM (predictor must be standardized)
single_trial_data$ISCR_z_pes <- NA
single_trial_data[!is.na(single_trial_data$pes), ] <- single_trial_data[!is.na(single_trial_data$pes), ] %>%
  dplyr::group_by(participant_id, session) %>%
  dplyr::mutate(ISCR_z_pes = scale(ISCR, center = TRUE, scale = TRUE)) %>%
  dplyr::ungroup()


# Run model
LMM_SCR_PES <- lmer(pes ~ ISCR_z_pes +
  (1 + ISCR_z_pes || participant_id),
data = single_trial_data,
REML = TRUE,
control = lmerControl(optimizer = "bobyqa")
)


# Check model output
# summary(LMM_SCR_PES) # Model does converge
# isSingular(LMM_SCR_PES) # Check for singular model fit (i.e., dimensions of the variance-covariance matrix have been estimated as exactly zero): FALSE


# Check PCA of random-effects variance-covariance estimates
# summary(rePCA(LMM_SCR_PES)) # All terms explain variance (> 0.5%)


# Display results (fixed effects)
tab_model(LMM_SCR_PES,
  dv.labels = "PES (robust)", pred.labels = c("(Intercept)" = "Intercept", "ISCR_z_pes" = "SCR"),
  show.stat = TRUE, show.icc = FALSE, show.r2 = FALSE,
  show.re.var = TRUE, show.ngroups = FALSE, string.est = "b", string.stat = "t value",
  string.ci = "95 % CI", string.p = "p value",  p.val = "satterthwaite"
)
```
<br><br>